
_SIGNALPROC_ASM	// comment if we do not want assembler processing

	.if defined (_SIGNALPROC_ASM)

_BLOCK_SIZE .equ 16
_L_CH .equ 0
_R_CH .equ 1
_LS_CH .equ 2
_RS_CH .equ 3
_C_CH .equ 4
_LFE_CH .equ 5

	.public _signalProcessing
	.extern _limiterThreshold
	.extern _variablesGain
	.extern _outputMode
	
 	.code_ovly 
 	
 	# prema CCC2 pozivnoj konvenciji: 
 	# i0 - parametar pokazivac, pIn
 	# i1 - parametar pokazivac, pOut
_signalProcessing:
	# na raspolaganju a0 a1 b0 b1 i4 i5 x0 x1 y0 y1
	
	ymem[i7] = i2;	i7+=1
	ymem[i7] = i3;	i7+=1
	ymem[i7] = i6;	
	
	i1 = i0 + (_R_CH * _BLOCK_SIZE)
	i2 = i0 + (_LS_CH * _BLOCK_SIZE)
	i3 = i0 + (_RS_CH * _BLOCK_SIZE)
	i4 = i0 + (_C_CH * _BLOCK_SIZE)
	i5 = i0 + (_LFE_CH * _BLOCK_SIZE)
	
	y0 = xmem[_variablesGain]
	y1 = xmem[_variablesGain + 1]
	i6 = (_limiterThreshold)
	
	a1 = xmem[_outputMode]
	
	do(_BLOCK_SIZE), >loop
		# ----------------------------------------------------------------------------
		# first stage, apply variable gain (L and R channel processing)
		# *samplePtrOutL = *samplePtrInL * *variablesGainPtrL;
		# *samplePtrOutR = *samplePtrInR * *variablesGainPtrR;
		x0 = ymem[i0]
		b0 = x0 * y0
		ymem[i0] = b0
		
		x0 = ymem[i1] 
		b0 = x0 * y1	
		ymem[i1] = b0
		# ----------------------------------------------------------------------------
		# if (outputMode > 0)
		b1 = (0)
		a1 - b1
		if (a < 0) jmp>end		
			# second stage, full wave rectifier distortion (LS and RS channel processing)
			# if (*samplePtrOutL < FRACT_NUM(0.0))
			#	*samplePtrOutLs = -*samplePtrOutL;
			# else
			#	*samplePtrOutLs = *samplePtrOutL;

			# if (*samplePtrOutR < FRACT_NUM(0.0))
			#	*samplePtrOutRs = -*samplePtrOutR;
			# else
			#	*samplePtrOutRs = *samplePtrOutR;
			a0 = ymem[i0]
			b0 = (0)
			a0 - b0
			if (a > 0) jmp>else
				a0 = -a0
%else:		ymem[i2] = a0

			a0 = ymem[i1]
			a0 - b0
			if (a > 0) jmp>else
				a0 = -a0
%else:		ymem[i3] = a0
		# ----------------------------------------------------------------------------
		# if (outputMode > 1)
		uhalfword(b1h) = (0x1)
		a1 - b1
		if (a < 0) jmp>end
			# third stage, L+R=C (C channel processing)
			# *samplePtrOutC = saturation(*samplePtrOutL + *samplePtrOutR);
			a0 = ymem[i0]
			b1 = ymem[i1];	i1+=1
			b0 = b1 + a0;	a0 = xmem[i6]
			if(a0 < b0) b0 = a0
			a0 = - a0
			if(a0 > b0) b0 = a0

			ymem[i4] = b0;	i4+=1
			
			# fourth stage, LS+RS=LFE (LFE channel processing)
			# *samplePtrOutLfe = saturation(*samplePtrOutLs + *samplePtrOutRs);
			a0 = ymem[i2];	i2+=1
			b1 = ymem[i3];	i3+=1
			b0 = b1 + a0;	a0 = xmem[i6]
			if(a0 < b0) b0 = a0
			a0 = - a0
			if(a0 > b0) b0 = a0
			
			ymem[i5] = b0;	i5+=1
				
%end:				
%loop:	i0+=1
	
	i6 = ymem[i7];	i7-=1
	i3 = ymem[i7];	i7-=1
	i2 = ymem[i7]

	ret
	
	.endif
	