
_SIGNALPROC_ASM	// comment if we do not want assembler processing

	.if defined (_SIGNALPROC_ASM)

_BLOCK_SIZE .equ 16
_L_CH .equ 0
_R_CH .equ 1
_LS_CH .equ 2
_RS_CH .equ 3
_C_CH .equ 4
_LFE_CH .equ 5

	.public _signalProcessing
	.extern _limiterThreshold
	.extern _variablesGain
	.extern _outputMode
	
 	.code_ovly 
 	
 	# prema CCC2 pozivnoj konvenciji: 
 	# i0 - parametar pokazivac, pIn
 	# i1 - parametar pokazivac, pOut
_signalProcessing:
	# na raspolaganju a0 a1 b0 b1 i4 i5
	i4 = (_variablesGain)
	
	do(_BLOCK_SIZE), >loop
		# ----------------------------------------------------------------------------
		# first stage, apply variable gain (L and R channel processing)
		# *samplePtrOutL = *samplePtrInL * *variablesGainPtrL;
		# *samplePtrOutR = *samplePtrInR * *variablesGainPtrR;
		i5 = i0 + (_L_CH * _BLOCK_SIZE)
		x0 = ymem[i5]
		y0 = xmem[i4]
		a0 = x0 * y0
		i5 = i1 + (_L_CH * _BLOCK_SIZE)
		ymem[i1] = a0
		
		i5 = i0 + (_R_CH * _BLOCK_SIZE)
		x0 = ymem[i5] 
		i4+=1
		y0 = xmem[i4]; i4-=1
		a0 = x0 * y0
		i5 = i1 + (_R_CH * _BLOCK_SIZE)
		ymem[i5] = a0
		# ----------------------------------------------------------------------------
		# if (outputMode > 0)
		a0 = xmem[_outputMode]
		b0 = (0)
		a0 - b0
		if (a < 0) jmp>end		
			# second stage, full wave rectifier distortion (LS and RS channel processing)
			# if (*samplePtrOutL < FRACT_NUM(0.0))
			#	*samplePtrOutLs = -*samplePtrOutL;
			# else
			#	*samplePtrOutLs = *samplePtrOutL;

			# if (*samplePtrOutR < FRACT_NUM(0.0))
			#	*samplePtrOutRs = -*samplePtrOutR;
			# else
			#	*samplePtrOutRs = *samplePtrOutR;
			i5 = i1 + (_L_CH * _BLOCK_SIZE)
			a0 = ymem[i5]
			b0 = (0)
			a0 - b0
			if (a > 0) jmp>else
				a0 = -a0
%else:		i5 = i1 + (_LS_CH * _BLOCK_SIZE)
			ymem[i5] = a0

			i5 = i1 + (_R_CH * _BLOCK_SIZE)
			a0 = ymem[i5]
			a0 - b0
			if (a > 0) jmp>else
				a0 = -a0
%else:		i5 = i1 + (_RS_CH * _BLOCK_SIZE)
			ymem[i5] = a0	
		# ----------------------------------------------------------------------------
		# if (outputMode > 1)
		a0 = xmem[_outputMode]
		uhalfword(b0h) = (0x1)
		a0 - b0
		if (a < 0) jmp>end
			# third stage, L+R=C (C channel processing)
			# *samplePtrOutC = saturation(*samplePtrOutL + *samplePtrOutR);
			i5 = i1 + (_L_CH * _BLOCK_SIZE)
			a1 = ymem[i5]
			i5 = i1 + (_R_CH * _BLOCK_SIZE)
			b1 = ymem[i5]
			a0 = a1 + b1
			
			# saturation(*samplePtrOutLs + *samplePtrOutRs);
			b0 = xmem[_limiterThreshold]
			a0 - b0
			if (a < 0) jmp>checkFmin
				a0 = b0			
%checkFmin:	b0 = -b0
			a0 - b0
			if (a >= 0) jmp>saturated
				a0 = b0
%saturated:
			i5 = i1 + (_C_CH * _BLOCK_SIZE)
			ymem[i5] = a0
			
			# fourth stage, LS+RS=LFE (LFE channel processing)
			# *samplePtrOutLfe = saturation(*samplePtrOutLs + *samplePtrOutRs);
			i5 = i1 + (_LS_CH * _BLOCK_SIZE)
			a1 = ymem[i5]
			i5 = i1 + (_RS_CH * _BLOCK_SIZE)
			b1 = ymem[i5]
			a0 = a1 + b1
			
			# saturation(*samplePtrOutLs + *samplePtrOutRs);
			b0 = xmem[_limiterThreshold]
			a0 - b0
			if (a < 0) jmp>checkFmin
				a0 = b0
%checkFmin:	b0 = -b0
			a0 - b0
			if (a >= 0) jmp>saturated
				a0 = b0
%saturated:
			i5 = i1 + (_LFE_CH * _BLOCK_SIZE)
			ymem[i5] = a0
				
%end:	
		i0+=1				
%loop:	i1+=1

	ret
	
	.endif
	